# 第4章 并发与同步

本章主要介绍了并发与同步中锁的应用与应当注意的问题。
	
## 4.1并发

### 引言
	
这几年并发技术受到前所未有的关注：CPU 进入多核时代，连手机芯片都使用三核的CPU(AP+BP+DSP 集成到一颗芯片)了。天生具有并发能力的语言 ErLang 逐渐成为热点。网格和云计算开始进入实用阶段。还有一些新技术更是让我闻所未闻，初学者也不用被这些铺天盖地的名词吓倒。据笔者的经验来看， 这些技术或许能够改变产业的格局，对人类生活造成重大影响，但从实现角度来看并不无多少革命，相反大部分都是传统技术的改进和应用。这几年我一直在研究开 源的基础软件，实际上我没有发现多少“新”东西或者核心技术。
		
要说真正的核心还是如序言中说的：战胜复杂度和应对变化。
		
作为系统程序员，掌握基础理论和经典的设计方法，比去追逐一些所谓的新技术要实用得多，基础打扎实了，学习新知识也是很容易的事。
	
### 任务：
		
了解linux下的多线程编程的基本方法，以双向链表为载体实现传统的生产者-消费者模型：一个线程往双向链表中加东西，另外一个线程从这里面取。
	
### 初学者常犯的错误：
		
#### (1)用临时变量作为线程参数的问题。

```C
#include <stdio.h>
#include <pthread.h>
#include <assert.h>
void* start_routine(void* param)
{
	char* str = (char*)param;
	printf("%s:%s\n", __func__, str);
	return NULL;
}
pthread_t create_test_thread()
{
	pthread_t id = 0;
	char str[] = "it is ok!";
	pthread_create(&id, NULL, start_routine, str);
	return id;
}
int main(int argc, char* argv[])
{
	void* ret = NULL;
	pthread_t id = create_test_thread();
	pthread_join(id, &ret);
	return 0;
}
```
			
	分析：由于新线程和当前线程是并发的，谁先谁后是无法预测的。可能create_test_thread 已经执行完了，str已经被释放了，新线程才拿到这参数，此时它的内容已经无法确定了，打印出的字符串自然是随机的

#### (2)线程参数共享的问题
	
```C
#include <stdio.h>
#include <pthread.h>
#include <assert.h>
void* start_routine(void* param)
{
	int index = *(int*)param;
	printf("%s:%d\n", __func__, index);
	return NULL;
}
#define THREADS_NR 10
void create_test_threads()
{
	int i = 0;
	void* ret = NULL;
	pthread_t ids[THREADS_NR] = {0};
	for(i = 0; i < THREADS_NR; i++)
	{
		pthread_create(ids + i, NULL, start_routine, &i);
	}
	for(i = 0; i < THREADS_NR; i++)
	{
		pthread_join(ids[i], &ret);
	}
	return ;
}
int main(int argc, char* argv[])
{
	create_test_threads();
	return 0;
}
```
	
	分析：由于新线程和当前线程是并发的，谁先谁后是无法预测的。i在不断变化，所以新线程拿到的参数值是无法预知的，打印出的字符串自然也是随机

#### (3)虚假并发
	
```C
#include <stdio.h>
#include <pthread.h>
#include <assert.h>
void* start_routine(void* param)
{
	int index = *(int*)param;
	printf("%s:%d\n", __func__, index);
	return NULL;
}
#define THREADS_NR 10
void create_test_threads()
{
	int i = 0;
	void* ret = NULL;
	pthread_t ids[THREADS_NR] = {0};
	for(i = 0; i < THREADS_NR; i++)
	{
		pthread_create(ids + i, NULL, start_routine, &i);
		pthread_join(ids[i], &ret);
	}
	return ;
}
int main(int argc, char* argv[])
{
	create_test_threads();
	return 0;
}
```
	
	分析：因为pthread_join会阻塞直到线程退出，所以这些线程实际上是串行执行的，一个退出了，才创建下一个。当年一个同事写了一个多线程的测试程序，就是这样写的，结果没有测试出一个潜伏的问题，直到产品运行时，这个问题才暴露出来。
	
访问线程共享的数据时要加锁，让访问串行化，否则就会出问题。比如，可能你正在访问的双向链表的某个结点时，它已经被另外一个线程删掉了。加锁的方 式有很多种，像互斥锁(mutex= mutual exclusive lock)，信号量(semaphore)和自旋锁(spin lock)等都是常用的，它们的使用同样很简单，我们就不多说了。

### 在加锁/解锁时，初学者常犯两个错误：

#### (1)存在遗漏解锁的路径。
	
	初学者常见的做法就是，进入某个临界函数时加锁，在函数结尾的地方解锁，甚至见过这种写法：
	
```C
{
	/*这里加锁*/
	…
	return …;
	/*这里解锁*/
}
```

如果你也犯了这种错误，应该好好反思一下。有时候，return的地方太多，在某一处忘记解锁是可能的，就像内存泄露一样，只是忘记解锁的后果更严重。

```C
Ret dlist_insert(DList* thiz, size_t index, void* data)
{
	DListNode* node = NULL;
	DListNode* cursor = NULL;
	return_val_if_fail(thiz != NULL, RET_INVALID_PARAMS);
	dlist_lock(thiz);
	if((node = dlist_create_node(thiz, data)) == NULL)
	{
		dlist_unlock(thiz);
		return RET_OOM;
	}
	if(thiz->first == NULL)
	{
		thiz->first = node;
		dlist_unlock(thiz);
		return RET_OK;
	}
	...
	dlist_unlock(thiz);
	return RET_OK;
}
```
	
如果一个函数有五六个甚至更多的地方返回，遗忘一两个地方是很常见的，即使没有忘记，每个返回的地方都要去解锁和释放相关资源也是很麻烦的。在这种情况下，我们最好是实现单入口单出的函数，常见的做法有两种：

#### (1)使用goto语句（在linux内核里大量使用）
	
```C
Ret dlist_insert(DList* thiz, size_t index, void* data)
{
	Ret ret = RET_OK;
	DListNode* node = NULL;
	DListNode* cursor = NULL;
	return_val_if_fail(thiz != NULL, RET_INVALID_PARAMS);
	dlist_lock(thiz);
	if((node = dlist_create_node(thiz, data)) == NULL)
	{
		ret = RET_OOM;
		goto done;
	}
	if(thiz->first == NULL)
	{
		thiz->first = node;
		goto done;
	}
	...
	done:
	dlist_unlock(thiz);
	return ret;
}
```
	
#### (2)使用do{}while(0);语句，出于受教科书的影响(不要用goto语句)，我习惯了这种做法。
	
```C
Ret dlist_insert(DList* thiz, size_t index, void* data)
{
	Ret ret = RET_OK;
	DListNode* node = NULL;
	DListNode* cursor = NULL;
	return_val_if_fail(thiz != NULL, RET_INVALID_PARAMS);
	dlist_lock(thiz);
	do
	{
		if((node = dlist_create_node(thiz, data)) == NULL)
		{
			ret = RET_OOM;
			break;
		}
		if(thiz->first == NULL)
		{
			thiz->first = node;
			break;
		}
		...
	}while(0);
	dlist_unlock(thiz);
	return ret;
}
```
	
#### (2)加锁顺序的问题
	
有时候为了提高效率，常常降低加锁的粒度，访问时不是用一个锁锁住整个数据结构，而是用多个锁来控制数据结构各个部分。这样一个线程访问 数据结构的这部分时，另外一个线程还可以访问数据结构的其它部分。但是在有的情况下，你需要同时锁几个锁，这时就要注意了：所有线程一定要按相同的顺序加锁，相反的顺序解锁。否则就可能出现死锁，两个线程都拿到对方需要的锁，结果出现互相等待的情况。


## 4.2同步


## 4.3嵌套与装饰模式


## 4.4读写锁


## 4.5无锁的数据结构