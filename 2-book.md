# 第2章 写的又快又好的秘诀

## 2.1 好与快的关系

“ 快”是指开发效率高，“好”是指软件质量高。呵呵，写得又快又好的人就是高手了。记得这是林锐博士下的定义，读他那篇著名的《C/C++高质量编程》时， 我还是个初学者，印象特别深。我现在仍然赞同他的观点，不过这里标题改为成为高手的秘诀，感觉就有点像标题党了，所以还是用比较通俗的说法吧。废话少说， 请读者回顾一下这段时间的编程经验，回答下面两个问题：

**快与好是什么关系？**

写得快就不能写得好？写得好就不能写得快？还是写得好才能写得快？ 是不是绕晕了？不过这确实是值得思考的问题。

**我们的时间花在哪里了？**

记得刚来深圳时到华为面试，面试的人是我的学长。他问我，你 一天能写多少行代码？我想了想说，100 行吧。他用看外行的 眼光看着我说，能写 100 行吗？我知道说错话了，赶快补充说，嗯，从整个项目来看可能没有吧。他才点了点头。一天只写100 行代码？初学者可能觉得不可思议，以同时应付 10 个网友聊天的速度，写 100 行代码不用三分钟。不过，经过这段时间的练习后，我们想大家已经明白，敲代码不是花时间最多的地方，那时间又花到哪里去了呢？

### 好与快的具体关系

几年前和一个朋友聊天时，他抱怨他的上司说，要我写得好又要写快，那怎么可能呢？我当时一愣，反问到，写不好怎么可能写得快？他也一愣。

传统观点认为在功能、成本(人*时间)和质量这个铁三角中，提高质量就意味投入更多成本或者减少一些功能。在功能不变的情况下，不可能在提高质量的同时降低开成成本(对个人来讲就是缩短开发时间)。我的朋友持的正是这种传统观点。

而根据我的经验来看，结论恰恰相反。每次我想以牺牲质量来加快速度的时候，结果反而花了更多时间，甚至可能到最后搞不定而放弃了。有了多次这样的经 验之后，我决定把每一步都做好，从开发的前期来看，我花的时间比别人多一点，但从整个任务来看，我反而能以别人几倍的速度完成任务。时间长了，我形成了这 样的观念：只有写得好才可能写得快。

两种观点截然相反，所以我们都愣了。虽然我相信我的经验没有错，但传统的铁三角定律是大师们总结出来的，也不可能出错。那是怎么回事呢？我开始到处 查资料，但是没有一个人支持我的观点。我又不想这样放弃，后来我用了一个简单的办法进行推理，结果证明两个观点都有各自的适用范围。

这个推理过程很简单，把两种观点推向极端：

先看看以牺牲质量来追求进度的例子。我以前参加过两个大项目，其一个项目的 BUG 总数达到 17000 多个，耗时近三年后项目被取消。另一个项目的 BUG 总数也超过 10000 个，三年之后带着很多 BUG 发布了，结果可想而知，产品很快从市场上消失了。这两个项目在开始阶段都制定了极其可笑的项目计 划，为了赶在这个根本不可能的最后期限前，都采用了牺牲质量的方式来提高开发速度，前期进展都很“顺利”，基本功能点很快就完成了，但是项目马上陷入了无止境的 debug 之中，开发人员的士气一下跌到谷底，管理层开始暴跳如雷。

如果这两个项目有超过 170000 个 BUG，即使项目不取消，再做时间十年也做不完。由此可见：质量低到一定限度时，降低质量会延长项目时间，如果质量降到最低，那项目永远也不可能完成。这和我的观点一致：写不好就写不快。

再看看追求完美质量的例子。以前参与一个手机模拟器的开发，我们很快达到 88%的真实度， 半年之后达到 95%的真实度，客户要 98%的真实度。但是怎么努力也达不到这个标准，花了极大的代价才达到 96%多一点，到后来项目被取消了。

如果要达到 99%的真实度，即使项目不取消，再做时间十年也做不完。由此可见：质量高到一定程度，提高质量会延长项目时间，如果质量要高到最高，那任务远也不可能完成。这和传统观点一致，提高质量就要延长开发时间。

从两个极端往中间走，我们可以找到一个中间质量点。低于这个质量点，想以牺牲质量来赶进度，那只会适得其反，质量越低耗时越长。高于这个质量点，想提高质量就得增加成本， 质量越高开发时间越长。这样两种观点就统一起来了。

如果在大多数项目中，这个中间质量点是可以作为高质量接受的，那我们就找到了又快又好的最佳方法。这个质量点到底是多少？呵，我可以告诉你，那是 87.5%。但是谁知道怎么去度量呢？没有人知道，只能凭感觉和经验了。

### 我们的时间花在哪里

经过这段时间的练习，大多数人都体会到敲代码不是耗费时间最多的地方，一个高效率的程序员，并不是打字比别人快，而他节省了别人浪费了的时间。我常 说达到别人五倍的效率并不难，因为在软件开发中，大部分人的大部分时间都浪费掉了，你只要把别人浪费的时间省下来，你的效率就提高上去了。像在优化软件性 能时采用的方法一样，要优化程序员的性能，我们要找出性能的瓶颈。也就是弄清楚我们的时间花在哪些地方，然后想办法省掉某些浪费了的时间。根据我的经验， 耗费时间最多的地方有：

**分析**

需求分析通常是 SPEC 工程师(或者所谓的系统分析员)的任务，程序员也会参与到这个过程中，但程序员的任务主要是理解需求，然后分析如何实现它 们，这个分析工作也就是软件设计。无论你是在计算机上用设计工具画出正规的软件架构图，还在纸上用自然语言描述出算法的逻辑，甚至在脑海中一闪而过的想法 都是设计。设计其实就是打草稿，把你的想法进行推敲，最后得到可行的方案。设计文档只是设计的结果，是设计的表现形式，没有写设计文档，并不代表没有做设 计(但是写设计文档可以加深你的思考)。

设计本身是一个思考过程，需要耗费大量时间，对于新手来说更是如此。前面几节中的需求并不难，理解它们只需要很少的时间，但要花不少时间去思考其实 现的方法。这个时间因人而异，有的读者到最后也没有想出办法，这没有关系，没有人天生就会的，不会的原因只是因为你暂时还不知道常用的设计方法，甚至连基 本数据结构和算法都不熟悉。

在后面的章节中，我们会一步步的深入学习各种常用设计方法，反复练习基本数据和算法， 熟能生巧，软件设计也一样，在你什么都不懂的时候，不可能做出好的设计。你要学习各种经典的设计方法，开始可能生搬硬套，多写多练多思考，到后来就随心所欲了，设计的时间就会大大缩短。

**测试**

要写得好自然离不开测试，初学者都有这个概念。他们忠实的使用了教科书上讲的方法，用scanf 输入数据，做些操作之后，用 printf 打印来，这 是一个完美的输入-处理-输出的过程。测试也就是要保证正确的输入能产生正确的输出，这种方法的原理是没有错的，但它们确实耗费了我们大量时间。

如果测试只需要做一次，这种方法还是可取的，问题是每次修改之后都要重复这个过程，耗费的时间就更多了。这种工作单调乏味，而且很难坚持做下去，单 元测试做得不全面，就有更多 BUG 等着就调试了。时间久了，或者换人维护了，谁也搞不清楚什么样输入产生什么样的输出，结果可能是连测试也省了，那就等着把大量的时间浪费在调试上吧。总而言之，这种测试方法不好，我们需要更有效的测试方法才行。

**调试**

测试时发现程序有 BUG，自然要用调试器了，对一些人来说，调试是一件充满挑战和乐趣的事。而对大部分人来说，特别是对我这种做过两年专职调试的人 来说，调试是件无趣无聊无用的工作。熟练使用调试器是必要的，在分析现有软件时，调试器是非常有用的工具。但在开发新软件时，调试器在浪费我们的时间。

调试器是最后一招，只有迫不得已时才使用。一位敏捷方法的高手说他已经记不得上次使用调试器是什么时候了，我想这就是为什么敏捷方法能够提高开发速度的原因吧。因为没有什么比一次性写好，不用调试器更快的方法了。

知道了浪费时间的地方，接下来几节中，我们将介绍避免浪费时间的方法。学完这些方法之后，我希望读者也能达到普通工程师五倍的效率，呵，读完本系列文章后之，希望你会达到更高。

## 2.2 代码阅读法

软件工程实践已经证明 Code Review 是提高代码质量最有效的手段之一，极限编程(XP)更是把 Code Review 推向极致，形成著名的结对编程工作方式，两个程序员在一台电脑前面工作， 一个人编写程序，另一个 Review 输入每一行代码，写程序人的专注于目前细节上的工作，Review 的人同时要从高层次考虑如何改进代码质量，两个人的角色会经常互换。

可惜我即没有结对编程的经验，也没有在 CMM3(及以上)团队中工作过。不过现在我要介绍比结对编程更敏捷更轻量级，但是同样有效的 Review 方 法。这种方法不需要其他程序员配合，有你自己就够了。为了把这种方法与传统的 Code Review 区分开来，我把它称为代码阅读法吧。

很多初学者包括一些有经验的程序员，在敲完代码的最后一个字符后，马上开始编译和运行， 迫不急待的想看到自己的工作成果。快速反馈有助于满足自己的成就感，但是同时也会带来一些问题：

让编译器帮你检查语法错误可以省些时间，但程序员往往太专注这些错误了，以为改完这些错误就万事大吉了。其实不然，很多错误编译器是发现不了的，像 内存错误和线程死锁等等，这些错误可能逃过简单的测试而遗留在代码中，直到集成测试或者软件发布之后才暴露出来，那时就要花更大代价去修改它们了。

修改完编译错误之后就是运行程序了，运行起来有错误，就轮到调试器上场了。花了不少时间去调试，发现无非是些低级错误，或许你会自责自己粗心大意， 但是下次可能还是犯同样的错误。更严重的是这种 debug & fix 的方法，往往是头痛医头脚痛医脚，导致低质量的软件。

让编译器帮你检查语法错误，让调试器帮你查 BUG，这是天经地义的事，但这确实是又慢又烂的方法。就像你要到离家东边 1000 米的地方开会，结果你往西边走，又是坐车又是搭飞机，花了一周时间，也绕着地球转了一周，终于到了会议室，你还大发感慨说，现代的交通工具真是发达啊。其实你往东走，走路也只要十多分钟就到了。不管你的调试技巧有多高，都不如一次性写好更高效。

我以前也一样，想赶时间结果花了更多时间，在经过很多痛苦的经历之后，我开始学会放松自己，让自己慢下来。写完程序之后，我会花些时间去阅读它，一遍两遍甚至多遍之后，才开始编译它，只要有时间，在通过测试之后，我还会阅读它们，每读一遍都有不同的收获， 有时候会发现一些错误，有时候会做些改进，有时候也有新的想法。

下面是我在阅读自己代码时的一些方法：

**检查常见错误**

第一遍阅读时主要关注语法错误、代码排版和命名规则等等问题，只要看不顺眼就修改它们。读完之后，你的代码很少有低级错误，看起来也比较干净清爽。 第二遍重点关注常见编程错误，比如内存泄露和可能的越界访问，变量没有初始化，函数忘记返回值等等，在后面的章节中，我会介绍这些常见错误，避免这些错误可以为你省大量的时间。如果有时间，在测试完成之后，还可以考虑是否有更好的实现方法，甚至尝试重新去实现它们。说了读者可能不相信，在学习编程的前几 年，我经常重写整个模块，只我觉得能做得更好，能验证我的一些想法，或提高我的编程能力，即使连续几天加班到晚上十一点，我也要重写它们。

**模拟计算机执行**

常见错误是比较死的东西，按照检查列表一条一条的做就行了。有些逻辑通常不是这么直观的，这时可以自己模拟计算机去执行，假想你自己是计算机，读入 这些代码时你会怎么处理。这种方法能有效的完善我们的思路，考虑不同的输入数据，各种边界值，这能帮助我们想到一些没有处理的情况，让程序的逻辑更严谨。

**假想讲给朋友听**

据说在 Code Review 时发现错误的，往往不是 Review 的人而是程序员自己。我也有很多这样的经历，在讲给别人听的时候，别人还没有听明白，自己已经发现里面存 在的错误了。上大学时，我常常把写的或者学到的东西讲给隔壁寝室的一个同学听，他说他从我这里学到很多知识，其实我从讲的过程中，经常发现一些问题，对提 高自己的能力大有帮助。可惜并不是随时都能找到好的听众，幸好我们有另外一个替代办法，记得刚开始写程序时看过一本书(忘记名字了)，作者说他在写程序时，常常把思路讲给他的布娃娃听。我没有布娃娃当听众，讲给鼠标听总是有点怪怪的 ，所以就假想旁边有个朋友，我把自己的思路讲给他听，同时也假想他来质疑我。这种方法很效，能够让自己的思路更清晰，据说一些大师也经常使用这种方法。

这种代码阅读法会花你一些时间，但是可以省下更多调试时间，而且能够提高代码质量，可以说是名符其实的“又快又好的” 秘诀之一。至于读几遍合适，要根据情况而定，个人觉得读两到三遍是最佳的投资。

## 2.3 避免常见错误

在 C 语言中，内存错误是最为人诟病的。这些错误让项目延期或者被取消，引发无数的安全问题，甚至出现人命关天的灾难。抛开这些大道理不谈，它们确实浪费了我们大量时间， 这些错误引发的是随机现象，即使有一些先进工具的帮助，为了找到重现的路径，花上几天时间也不足为怪。如果能够在编写代码的时候避免这些错误，开发效率至少提高一倍以上，质量可以提高几倍了。这里列举一些常见的内存错误，供新手参考。

**内存泄露**

大家都知道，在堆上分配的内存，如果不再使用了，应该把它释放掉，以便后面其它地方可以重用。在 C/C++中，内存管理器不会帮你自动回收不再使用的内存。如果你忘了释放不再使用的内存，这些内存就不能被重用了，这就造成了所谓的内存泄露。

把内存泄露列为首位，倒并不是因为它有多么严重的后果，而因为它是最为常见的一类错误。一两处内存泄露通常不至于让程序崩溃，也不会出现逻辑上的错 误，加上进程退出时，系统会自动释放该进程所有相关的内存(共享内存除外)，所以内存泄露的后果相对来说还是比较温和的。但是，量变会导致质变，一旦内存 泄露过多以致于耗尽内存，后续内存分配将会失败，程序可能因此而崩溃。

现在 PC 机的内存够大了，加上进程有独立的内存空间，对于一些小程序来说，内存泄露已经不是太大的威胁。但对于大型软件，特别是长时间运行的软件，或者嵌入式系统来说，内存泄露仍然是致命的因素之一。

不管在什么情况下，采取谨慎的态度，杜绝内存泄露的出现，都是可取的。相反，认为内存 有的是，对内存泄露放任自流都不是负责的。尽管一些工具可以帮助我们检查内存泄露问题， 我认为还是应该在编程时就仔细一点，及早排除这类错误，工具只是用作验证的手段。

**内存越界访问**

内存越界访问有两种：一种是读越界，即读了不属于自己的数据，如果所读的内存地址是无效的，程度立刻就崩溃了。如果所读内存地址是有效的，在读的时候不会出问题，但由于读到的数据是随机的，它会产生不可预料的后果。另外一种是写越界，又叫缓冲区溢出，所写入的数据对别人来说是随机的，它也会产生不可 预料的后果。

内存越界访问造成的后果非常严重，是程序稳定性的致命威胁之一。更麻烦的是，它造成的后果是随机的，表现出来的症状和时机也是随机的，让 BUG 的现象和本质看似没有什么联系，这给 BUG 的定位带来极大的困难。

一些工具可以够帮助检查内存越界访问的问题，但也不能太依赖于工具。内存越界访问通常是动态出现的，即依赖于测试数据，在极端的情况下才会出现，除 非精心设计测试数据， 工具也无能为力。工具本身也有一些限制，甚至在一些大型项目中，工具变得完全不可用。比较保险的方法还是在编程是就小心，特别是对于 外部传入的参数要仔细检查。

我们来看一个例子：

```c
#include <stdlib.h>
#include <string.h>

int main(int argc, char* argv[])
{
    char str[10];
    int array[10] = {0,1,2,3,4,5,6,7,8,9};

    int data = array[10]; 
    array[10] = data; 

    if(argc == 2)
    {
        strcpy(str, argv[1]);
    }
    return 0;
}
```

这个例子中有两个错误是新手常犯的：

其一：`int array[10]` 定义了 10 个元素大小的数组，由于 C 语言中数组的索引是从 0 开始的， 所以只能访问 `array[0]` 到 `array[9]` ，访问 `array[10]` 就造成了越界错误。

其二：`strcpy(str, argv[1]);` 这里是否存在越界错误依赖于外部输入的数据，这样的写法在正常下可能没有问题，但受到一点恶意攻击就完蛋了。除非你确定输入数据是在你控制内的， 否则不要用 `strcpy`、`strcat` 和 `sprintf` 之类的函数，而要用 `strncpy`、`strncat` 和 `snprintf` 代替。

**野指针**

野指针是指那些你已经释放掉的内存指针。当你调用 `free(p)` 时，你真正清楚这个动作背后的内容吗？你会说 p 指向的内存被释放了。没错，p 本身有变化吗？答案是 p 本身没有变化。它指向的内存仍然是有效的，你继续读写 p 指向的内存，没有人能拦得住你。

释放掉的内存会被内存管理器重新分配，此时，野指针指向的内存已经被赋予新的意义。对野指针指向内存的访问，无论是有意还是无意的，都为此会付出巨大代价，因为它造成的后果，如同越界访问一样是不可预料的。

释放内存后立即把对应指针置为空值，这是避免野指针常用的方法。这个方法简单有效，只是要注意，当然指针是从函数外层传入的时，在函数内把指针置为空值，对外层的指针没有影响。比如，你在析构函数里把 this 指针置为空值，没有任何效果，这时应该在函数外层把指针置为空值。

**访问空指针**

空指针在 C/C++中占有特殊的地址，通常用来判断一个指针的有效性。空指针一般定义为0。现代操作系统都会保留从 0 开始的一块内存，至于这块内存有多大，视不同的操作系统而定。一旦程序试图访问这块内存，系统就会触发一个异常/信号。

操作系统为什么要保留一块内存，而不是仅仅保留一个字节的内存呢？原因是：一般内存管理都是按页进行管理的，无法单纯保留一个字节，至少要保留一个页面。保留一块内存也有额外的好处，可以检查诸如 p=NULL; p[1]之类的内存错误。

在一些嵌入式系统(如 arm7)中，从 0 开始的一块内存是用来安装中断向量的，没有 MMU 的保护，直接访问这块内存好像不会引发异常。不过这块内存是代码段的，不是程序中有效的变量地址，所以用空指针来判断指针的有效性仍然可行。

**引用未初始化的变量**

未初始化变量的内容是随机的(有的编译器会在调试版本中把它们初始化为固定值，如

0xcc)，使用这些数据会造成不可预料的后果，调试这样的 BUG 也是非常困难的。

对于态度严谨的程度员来说，防止这类 BUG 非常容易。在声明变量时就对它进行初始化， 是一个好的编程习惯。另外也要重视编译器的警告信息，发现有引用未初始化的变量，立即修改过来。

在下面这个例子中，全局变量 g_count 是确定的，因为它在 bss 段中，自动初始化为 0 了。临时变量 a 是没有初始化的，堆内存 str 是没有初始化 的。但这个例子有点特殊，因为程序刚运行起来，很多东西是确定的，如果你想把它们当作随机数的种子是不行的，因为它们还不够随机。

```c
#include <stdlib.h>
#include <string.h> 

int g_count;

int main(int argc, char* argv[])
{
    int a;
    char* str = (char*)malloc(100); return 0;
}
```


**不清楚指针运算**

对于一些新手来说，指针常常让他们犯糊涂。

比如 `int *p = …; p+1` 等于`(size_t)p + 1` 吗

老手自然清楚，新手可能就搞不清了。

事实上, `p+n` 等于 `(size_t)p + n * sizeof(*p)`

指针是 C/C++中最有力的武器，功能非常强大，无论是变量指针还是函数指针，都应该非常熟练的掌握。只要有不确定的地方，马上写个小程序验证一下。对每一个细节了然于胸，在编程时会省下不少时间。

**结构的成员顺序变化引发的错误**

在初始化一个结构时，老手可能很少像新手那样老老实实的，一个成员一个成员的为结构初始化，而是采用快捷方式，如：

```c
Struct s
{
    int   l;
    char* p;
};

int main(int argc, char* argv[])
{
    struct s s1 = {4, "abcd"};
    return 0;
}
```


以上这种方式是非常危险的，原因在于你对结构的内存布局作了假设。如果这个结构是第三方提供的，他很可能调整结构中成员的相对位置。而这样的调整往 往不会在文档中说明，你自然很少去关注。如果调整的两个成员具有相同数据类型，编译时不会有任何警告，而程序的逻辑可能相距十万八千里了。

正确的初始化方法应该是（当然，一个成员一个成员的初始化也行）：

```c
struct s
{
    int   l; 
    char* p;
};

int main(int argc, char* argv[])
{
    struct s s1 = {.l=4, .p = "abcd"}; 
    return 0;
}
```


> 有的编译器可能不支持新标准

**结构的大小变化引发的错误**

我们看看下面这个例子：

```c
struct base
{
    int n;
};

struct s
{
    struct base b;
    int m;
};
```

在 OOP 中，我们可以认为第二个结构继承了第一结构，这有什么问题吗？当然没有，这是 C 语言中实现继承的基本手法。

现在假设第一个结构是第三方提供的，第二个结构是你自己的。第三方提供的库是以 DLL方式分发的，DLL 最大好处在于可以独立替换。但随着软件的进化，问题可能就来了。

当第三方在第一个结构中增加了一个新的成员 int k;，编译好后把 DLL 给你，你直接把它给了客户了，让他们替换掉老版本。程序加载时不会有任何问题，在运行逻辑可能完全改变！ 原因是两个结构的内存布局重叠了。

解决这类错误的唯一办法就是重新编译全部代码。由此看来，动态库并不见得可以动态替换， 如果你想了解更多相关内容，建议你阅读《COM 本质论》。

**分配/释放不配对**

大家都知道 malloc 要和 free 配对使用，new 要和 delete/delete[]配对使用，重载了类 new 操作， 应该同时重载类的 delete/delete[]操作。这些都是书上反复强调过的，除非当时晕了头，一般不会犯这样的低级错误。

而有时候我们却被蒙在鼓里，两个代码看起来都是调用的 free 函数，实际上却调用了不同的实现。比如在 Win32 下，调试版与发布版，单线程与多线 程是不同的运行时库，不同的运行时库使用的是不同的内存管理器。一不小心链接错了库，那你就麻烦了。程序可能动则崩溃，原因在于在一个内存管理器中分配的内存，在另外一个内存管理器中释放时就会出现问题。

**返回指向临时变量的指针**

大家都知道，栈里面的变量都是临时的。当前函数执行完成时，相关的临时变量和参数都被清除了。不能把指向这些临时变量的指针返回给调用者，这样的指针指向的数据是随机的，会给程序造成不可预料的后果。

下面是个错误的例子：

```c
char* get_str(void)
{
    char str[] = {"abcd"};
    return str;
}

int main(int argc, char* argv[])
{
    char* p = get_str();
    printf("%s\n", p);
    return 0;
}
```


下面这个例子没有问题，大家知道为什么吗？

```c
char* get_str(void)
{
    char* str = {"abcd"};
    return str;
}

int main(int argc, char* argv[])
{
    char* p = get_str();
    printf("%s\n", p);
    return 0;
}
```


**试图修改常量**

在函数参数前加上 const 修饰符，只是给编译器做类型检查用的，编译器禁止修改这样的变量。但这并不是强制的，你完全可以用强制类型转换绕过去，一般也不会出什么错。

而全局常量和字符串，用强制类型转换绕过去，运行时仍然会出错。原因在于它们是放在.rodata 里面的，而.rodata 内存页面是不能修改的。试图对它们修改，会引发内存错误。

下面这个程序在运行时会出错：

```c
int main(int argc, char* argv[])
{
    char* p = "abcd";
    *p = '1';
    return 0;
}
```


**误解传值与传引用**

在 C/C++中，参数默认传递方式是传值的，即在参数入栈时被拷贝一份。在函数里修改这些参数，不会影响外面的调用者。如：

```c
#include <stdlib.h>
#include <stdio.h>

void get_str(char* p)
{
    p = malloc(sizeof("abcd"));
    strcpy(p, "abcd");
    return;
}

int main(int argc, char* argv[])
{
    char* p = NULL;
    get_str(p);
    printf("p=%p\n", p); return 0;
}
```

在 main 函数里，p 的值仍然是空值。当然在函数里修改指针指向的内容是可以的。

**重名符号**

无论是函数名还是变量名，如果在不同的作用范围内重名，自然没有问题。但如果两个符号的作用域有交集，如全局变量和局部变量，全局变量与全局变量之 间，重名的现象一定要坚决避免。gcc 有一些隐式规则来决定处理同名变量的方式，编译时可能没有任何警告和错误，但结果通常并非你所期望的。

下面例子编译时就没有警告：

t.c

```c

#include <stdlib.h>
#include <stdio.h>

int count = 0;

int get_count(void)
{
    return count;
}
```

main.c

```c
#include <stdio.h>

extern int get_count(void);
int count;

int main(int argc, char* argv[])
{
    count = 10;
    printf("get_count=%d\n", get_count()); 
    return 0;
}
```

如果把 main.c 中的 `int count;` 修改为 `int count = 0;` ，gcc 就会编辑出错，说 `multiple definition of 'count'` 。它的隐式规则比较奇妙吧，所以还是不要依赖它为好。

**栈溢出**

我们在前面关于堆栈的一节讲过，在 PC 上，普通线程的栈空间也有十几M，通常够用了，定义大一点的临时变量不会有什么问题。

而在一些嵌入式中，线程的栈空间可能只 5K 大小，甚至小到只有 256 个字节。在这样的平台中，栈溢出是最常用的错误之一。在编程时应该清楚自己平台的限制，避免栈溢出的可能。

**误用 sizeof**

尽管 C/C++通常是按值传递参数，而数组则是例外，在传递数组参数时，数组退化为指针（即按引用传递），用 sizeof 是无法取得数组的大小的。从下面这个例子可以看出：

```c
void test(char str[20])
{
    printf("%s:size=%d\n", func , sizeof(str));
}

int main(int argc, char* argv[])
{
    char str[20] = {0}; 
    test(str);
    printf("%s:size=%d\n", func , sizeof(str)); 
    return 0;
}
```

```
[root@localhost mm]# ./t.exe 
test:size=4
main:size=20
```


**字节对齐**

字节对齐主要目的是提高内存访问的效率。但在有的平台(如 arm7)上，就不光是效率问题了，如果不对齐，得到的数据是错误的。

所幸的是，大多数情况下，编译会保证全局变量和临时变量按正确的方式对齐。内存管理器会保证动态内存按正确的方式对齐。要注意的是，在不同类型的变量之间转换时要小心，如把 char*强制转换为 int*时，要格外小心。

另外，字节对齐也会造成结构大小的变化，在程序内部用 sizeof 来取得结构的大小，这就足够了。若数据要在不同的机器间传递时，在通信协议中要规定对齐的方式，避免对齐方式不一致引发的问题。

**字节顺序**

字节顺序历来是设计跨平台软件时头疼的问题。字节顺序是关于数据在物理内存中的布局的问题，最常见的字节顺序有两种：大端模式与小端模式。

大端模式是高位字节数据存放在低地址处，低位字节数据存放在高地址处。

小端模式指低位字节数据存放在内存低地址处，高位字节数据存放在内存高地址处；

在普通软件中，字节顺序问题并不引人注目。而在开发与网络通信和数据交换有关的软件时，字节顺序问题就要特殊注意了。

**多线程共享变量没有用 valotile 修饰**

> (volatile?)


关键字 valotile 的作用是告诉编译器，不要把变量优化到寄存器里。在开发多线程并发的软件时，如果这些线程共享一些全局变量，这些全局变量最好用 valotile 修饰。这样可以避免因为编译器优化而引起的错误，这样的错误非常难查。

**忘记函数的返回值**

函数需要返回值，如果你忘记 return 语句，它仍然会返回一个值，因为在 i386 上，EAX 用来保存返回值，如果没有明确返回，EAX 最后的内容被返回，所以 EAX 的内容是随机的。

## 2.4 自动测试

手工测试比没有测试强一点，但是它存在的问题让它很难在实践中应用：手工输入数据的过 程单调乏味，很难长期坚持。每次都要重新输入数据，浪费大量时 间。测试用例不能累积， 测试往往不完整。用人脑判断输出的正误，浪费人力也存在误差。要写得好测试自然不能省， 要写得快就需要更好的测试方法。

更好的测试方法当然是自动测试了。幸运的是，刚进入这个行业我就接触了自动的测试 (呵，读本文的初学者就更幸运了)，我的第一份正式工作是在测试组写测试程序。当时测试组也算是人才济济了，居然有几个北大毕业的，不过她们都不懂 Linux，所以我被指派去为移植到 Linux 上的模块写测试程序。这些模块都有测试程序，但这些测试程序的功能太弱了，我的上司要求开发人员改进，但那 些开发人员太自以为是了，根本不理我们，所以我们只好自己重写这些测试程序。模块很多，大概有 50 多个模块，熟悉这些模块也需要不少时间， 按每两个工作日 写一个测试程序，上司给我 5 个月时间。

记得第一个模块是 RDFParser，RDF(资源描述框架)是 XML 的一种应用，RDFParser 实际上是一个 XML 解析器，并包装成 RDF 要 求的接口。由于我对 C/C++还不太熟悉，对 RDF 更不熟悉了，花了两周时间才写出这个测试程序。运行起来有些不正常，我确信不是测试程序的问题，就去请 开发人员帮忙来看一下。负责 RDFParser 的那个程序员是人大毕业，我没有见过第二个比他更自以为是的程序员了，他刚在我座位上坐下就很大声说，你们 QA 的人太蠢了！

当时一听就愣了，不过我是新来的，见上司都没反应，自然就忍了。我列举了一些证据是模块里面的问题，他听也不听，只是不断重复的说，不可能是我程序 的问题，你们 QA 的人太蠢了，总是浪费我的时间。过了一会儿，他终于闭上了嘴巴，又等了一会儿才说，等会儿重新发个版本给你吧。后来又请他过来四五次，结 果每次都是他的问题。

之后我再没有听到他说过你们 QA 的人太蠢了的话。为了避免让他抓到把柄来嘲笑测试组， 我决定请他来查问题之前做更详细的测试。当时我写的测试程序和 现在初学者写的测试程序没有两样，都是从教科书上学来的，先通过 scanf 从终端输入数据，调用被测函数，再把结果 printf 出来，这花了我太多时间。 想到后面还有 50 多个模块的测试程序要写，这样下去不行，一定得想个办法。

后来我把输入的数据和期望的结果都写到一个 INI 文件中，测试程序从这个文件中读入数据，运行测试，再和预期结果比较，整个过程都自动化了。写了一 个 INI 文件的解析器花了我一周时间，又重写了那个测试程序，整整花了我一个月时间完成 RDFParser 的测试程序。进度自然大落后了，还好上司知道后 并没有责备我，让我慢慢做就好了。

写第二个测试程序时把 INI 解析的代码拷贝过去，再加一些调用模块的代码就写好了，第三个也是如此。写了几个之后，我发现了 INI 解析有个 BUG， 结果每个测试程序我都要去修改，想到维护起来太麻烦了，就把 INI 解析器的接口规范化了，编译成一个独立共享库。又写了几个测试程序，我写烦了，原因是测 试程序无非就是读入数据，调用被测函数，再检查结果，这个过程太无聊了。想到后面还要把这个过程重复几十遍，郁闷了几天之后，突然灵机一动，我决定写了一 个代码产生器来产生这些代码。开始的代码产生器用 C 写的，用一个简单的规则来描述被测函数，通过这些规则来产生测试程序。我把这些东西和 INI 解析器放在 一个独立的库中，把它叫作 TesterFrameWork，经过几个测试程序的验证和完善，后来利用这个 TesterFrameWork，只要一两个小时 就能完成一个测试程序了。有次请开发人员那边一个高手帮我查一个问题，他看一会儿我的 TesterFrameWork 之后，盯着我说，你太聪明了。我笑了 笑说，刚刚开始写 C/C++程序。

一年之后我知道了有个 CPPUnit 之后，为了赶时髦我把 TesterFrameWork 改名为 CxxUnit，非典的时候放假无聊就把它重写了一遍放在 cosoft 上了(之后没有管过它，或许还在吧)。

一个大系统很难自动测试，而一个独立的模块则是最佳的自动测试单元。自动测试和单元测试几乎成了等价的概念，很多人都以为自动测试就是利用 CPPUnit 这样的单元测试框架写个测试程序而已，这完全是错误的，就像有人以为有个设计文档的模板，照着填空就能填出好设计一样。

我自己实现过单元测试框架，不是像有些人出于模仿去实现，而完全出于实际的需要，后来我也研究其它测试框架，应该说我对测试程序框架的认识比一般程 序员要深刻。我认为测试程序框架可以减化一些测试程序的工作，但它与自动测试没有密切关系，用不用测试程序框架完全是个人喜好。用测试程序框架未必能写出 好的测试程序，就像用 C++未必能写出好的面向对象的程序一样。

虽然我顺利的完成了那个写测试程序的任务，但我一直被一个问题困扰：如何写测试用例， 如何去检测结果？这是测试程序框架帮不上忙的。写测试用例还好 说，通过边界值法，等价类法和路径覆盖法找到最常用的测试用例。检测结果呢？有人说很简单啊，判断返回值就好了。那我问一下 dlist_insert 返回 OK，就真的 OK 了吗？如果一个函数根本没有返回值， 那你怎么判断呢？

测试程序框架是敏捷论者提倡的，在我看来它根本不够敏捷：你要去学习它，了解它的运行机制，要包含它的头文件，链接它的库，有比不用它更敏捷么？重 要的是它根本帮不上什么有用的忙。前面的问题折磨了我一段时间，于是得出一个可能有点偏激的结论：测试程序框架都是愚蠢的，你真正需要的，它根本帮不了你 (我知道这样说会得罪一些用测试程序框架的朋友，如果你想找我讨论的话，请看完本节的附带示例代码再说)。

就在那个时候，我看到了孟岩老师翻译的《契约式设计(Design by Contract)》，读完之后豁然开朗。或许我还没有明白契约式设计的本质，但我确实知道了写自动测试程序的方法，下面我介绍一下：

- 在设计时，每个函数只完成单一的功能。单一功能的函数容易理解，也容易预测其行为。对测试来说，给定一些输入数据，就知道它的输出和影响，这样函数是最容易测试的。
- 在设计时，把函数分为查询和命令两类。查询函数只查询对象的状态，而不改变对象的状态。命令函数则只修改对象的状态，只返回其操作是否成功的标志，而不返 回对象的状态。比如，dlist_length 查询双向链表的长度，它不修改双向链表的任何状态。dlist_delete 修改对象的状态(删除结点)， 并返回其操作是否成功，而不返回当前长度或者删除的结点之类的状态。
- 在设计时，把查询分为基本查询和复合查询两类。基本查询函数只查询单一的状态，而复合查询可以同时查询多个状态。比如，window_get_width 返回窗口的宽度，这是基本查询函数，widget_get_rect 返回窗口的左上角坐标，宽度和高度，这是复合查询函数。
- 在实现时，检验输入数据，确认使用者正确的调用了函数。契约式设计规定了调用者和实现者双方的责任，调用者需要使用正确的参数，才能保证有正确的 结果。政治家告诉我们，信任但要检查，所以作为实现者就需要检查输入参数是否违背了契约。

那怎么检查呢？有人说，如果检查到无效参数就返回一个错误码。这 当然可以，只是不太好，因为大多数人都没有检查返回值的习惯，如果每个地方都检查函数的返回值，也是件很繁琐的事，代码看起来也比较乱。通常我们只检查一 些关键的地方，对于无效参数这样的错误，可能就无声无息的隐藏起来了，这样不好，因为隐藏得越深，发现的时间越晚，修改的代价越大。

在 C++和 JAVA 里，如果参数不正确，通常是 throw 一个无效参数之类的异常，C 语言里面

没有异常这个概念，我们需要其它办法才行。有人推荐用 assert 来检查，这是一个好办法，

assert 只在调试版本中有效(没有定义 NDEBUG)，这样任何无效调用都在调试版本中暴露出来了。如果配合前 面返回错误码的方法，在发布版本中也可能避免程序粗暴的死掉。使用方法如下：

```c
assert(thiz != NULL); if(thiz == NULL)
{
    return DLIST_RET_INVALID_PARAMS;
}
```

我一直使用这种方法，但是有个问题：无法用自动测试验证 assert 是否正常的触发了，当用错误的参数测试时，我期望 assert 被触发，但如果 assert 被触发了，自动程序测试就死掉了， 自动测试程序死掉了，就无法继续验证下一个 assert。这是一个悖论！

后来我从 glib 里面学了一招，它检查时不用 assert，只是打印出一个警告，代码也简明了，

按它的方式，我们这样检查：

```c
return_val_if_fail(cursor != NULL, DLIST_RET_INVALID_PARAMS);
```

我们需要定义两个宏，一个用于无返回值的函数，一个用于有返回值的函数：

```c
#define return_if_fail(p) if(!(p))               \
    {printf("%s:%d Warning: "#p" failed.\n",     \
        __func__ , __LINE__ ); return;}

#define return_val_if_fail(p, ret) if(!(p))      \
    {printf("%s:%d Warning: "#p" failed.\n",     \
        __func__ , __LINE__ ); return (ret);}
```

这样一来，遇到无效参数时，可以看到一个警告信息，同时又不会影响自动测试。

- 在测试时，用查询来验证命令。命令一般都有返回值，但只检查返回值是不够的。比如dlist_delete 返回 OK，它真的 OK 了吗？我们信任它，但还是要检查。怎么检查？很简单， 用查询函数来检查对象的状态是不是预期的。

  对于 dlist_delete，我们预期：

  1. 输入无效参数，期望返回 DLIST_RET_INVALID_PARAMS。

  2. 输入正确参数，期望：函数返回 DLIST_RET_OK；双向链表的长度减一。删除的位置的下一个元素被移到删除的位置。

  在测试程序中检查时，因为任何不符合期望的结果都是 BUG，所以我们用 assert 检查。这样有问题马上暴露出来了，定位错误比较容易，通常都不需要调试器。我们这样来检查：

  ```c
  assert(dlist_length(dlist) == (n-i));
  assert(dlist_delete(dlist, 0) == DLIST_RET_OK);
  assert(dlist_length(dlist) == (n-i-1));
  
  if((i + 1) < n)
  {
      assert(dlist_get_by_index(dlist, 0, (void**)&data) == DLIST_RET_OK);
      assert((int)data == (i+1));
  }
  ```
  (完整的例子请看本节的示例代码)

- 在测试时，用基本查询去验证复合查询。基本查询和复合查询返回的应该一致。比如：

  ```c
  Rect rect = {0};
  
  widget_get_rect(widget, &rect);
  assert(widget_get_width(widget) == rect.width);
  assert(widget_get_height(widget)== rect.height);
  ```

- 在测试时，预期结果依赖其执行上下文，我们要按逻辑组织测试用例。前面调用的函数可能改变了对象的状态，为了简化测试，在每组测试用例开始时，都重置对象到初始状态。

- 在测试时，第一次只写基本的测试用例，以后逐渐累积，每次发现新的 BUG 就把相应的测试用例加进去。每次修改了代码就运行一遍自动测试，保证修改没有引起其它副作用。

按着上面的原则，应付正常模块的测试没有问题了，但是下面的情况仍然比较棘手：

- 带有 GUI 的应用程序。有 GUI 的程序会给自动的输入数据和检查结果带来困难，有些工具可以部分解决这个问题，特别是针对 Win32 下的 GUI，我很少在 Windows 下写程序，所以对这方面了解不多。不过最好的办法还是用 MVC 模型等分离界面和实现，因为界面通常相对比较简单，可以手工测试，而实现的逻 辑比较复杂，这部分可以自动测试。后面我们会专门讲解分离界面和实现的方法。

- 有随机数据输入。如果有些输入数据是内部随机产生的，那你根本无法预测它的输出结果和影响。比如游戏随机的步骤和无线网络信号的变化。对于我们可以控制的 随机数据，可以提供额外的函数去获取这些数据。对于无法控制的随机输入数据，可以把它们隔离开，在自动测试中，使用固定的数据。
- 多线程运行的程序。多线程的程序也很难自动测试，比如向链表中插入一个元素，当你检查的时候，根本无法知道链表的长度是否增加，也无法知道刚才插入的位置 是否是你插入的元素，因为这个时候，可能有另外一个线程已经把它删除了，或者又加入了新的数据。不过在单线程的自动测试通过之后，多线程的问题会大大减 少，剩下的问题我们可以通过其它方式加以避免。

写自动测试程序会花你一些时间，但这个投资能带来最大的回报：减少后面调试时的浪费，提高代码的质量，更重要的是你可以安稳的睡个觉了。

本节示例请到[**这里**](http://www.limodev.cn/bbs/download/file.php?id=10)下载。 

## Save your work

> “Ernst 和 Young 所在的小组决定使用正规的开发理论—他们常用削减法，分阶段进行开发并具有中途交付能力。他们的步骤包括细致的分析和设计 —正如本章描写的基本原则一样。而其他竞争者径直开始了编码，在开始几个小时里，Ernst 和 Young 小组落后了。但到中午时 Ernst 和 Young 小 组却是遥遥领先了，而到了这一天的最后，他们却失败了。导致失败的原因不是因为他们的正规方法，而是他们偶然错误的把工作文件覆盖了，最终他们比午餐时所做的估计少交付了一些功能，他们是被没有使用有效的源程序版本控制这个典型的错误给打败了。”
>
> ——摘自《快速软件开发》

前段时间看探索频道的《荒野求生秘技(Man & wild)》，我很喜欢这个节目也喜欢那个英国佬，甚至连重播都不会放过。他展示在沙漠、丛林、冰河和雪山等各种环境的求生秘技，他吃蜘蛛、白蚁、蝎子和 蜥蜴，边吃边说这东西很恶心，但是里面含有非常的维生素，蛋白质和糖份，能够 Save your life，所以要吃下去。

在 Man & Code 的世界里，环境好多了，不用面临危险，寻找水源和食物根本不需要什么秘诀。这里我们不需要求生秘技去 Save your life，但我们需要一些习惯去 Save your work。我说过作为一名高效的程序员，不是因为他打字比别人快，而是因为他省下了别人浪费的时间， 有什么比成果被毁，从头再来更浪费时间呢？下面我介绍 一些习惯，它们简单有效，根本算不上什么秘技，但它们能够 Save your work，让你的工作稳步前进。

**随时存盘**

每次停电时，我都会听到有人惊呼，完了，我的代码没有保存！补回半小时或一个小时的工作不难，在一个好的工作环境里，这种情况一年也就会遇到几次， 浪费的时间完全可以忽略不计。但是那种感觉很难受，会影响你的工作情绪，无缘无故的让你重做你的工作，和因为要改进去重做完全是两回事。在我以前工作过的 一个公司，有段时间经常跳闸，每周都要停好几次，怎么也找不到原因，后来请人来查，据说是线路太长，静电引起的跳闸。经过那段时间的折磨，我养成了一个习 惯：写代码的时候，平均 30 秒钟存盘一次。现在遇到停电，别人惊呼的时候，我开始闭目养神了。

**使用版本控制系统**

和一些老程序员聊天时(呵，其实我也老了)，他们经常问起我们项目有没有使用版本控制系统，我说当然有了，大二的时候就我用 Sourcesafe 来 管理用 powerbuilder 写的代码了，后来的工作中一直在使用不同的版本控制系统。接着他们开始讲述他们惨痛的经历…这些经历小则让他们项目延期， 大则导致整个项目失败。

版本控制系统有很多功能，但对我个人来说，它最重要的功能是备份代码。每完成一个小功能，我都会把它提交(checkin)进去，如果我不小心删除 了本地文件，或者某个做尝试的修改失败了，我可以恢复代码到前一个版本。不同团队有不同的规则，有的团队是不允许这样checkin 的，他们只允许 checkin 经过严格测试的代码。如果是那样，你可以在本地建立自己的版本控制系统，初学者在学习时也可以这样做。现在有很多免费的版本控制系统可用， 像 CVS、SVN 和 GIT 等等，我个人习惯用 CVS，SVN 是 CVS 的改进版，将来肯定会替代SVN 的，所以推荐大家使用它。

**定期备份**

温伯格在《Quality Software Management: System Thinking》讲了一个有趣的故事，他以前去研究一些失败的案例，发现这些项目的失败都是因为欠佳的运气引起的：比如遭受到洪水、地震、火灾和流行感 冒等灾害，项目主管们把自己描述成外部问题的受害者。他又对另外一些成功的项目进行研究，发现其中有些项目同样经历这些自然灾害，但是他们成功的完成了任 务。区别只是在于成功项目的主管，采用积极预防措施，定期备份代码，把它们放到不同的地点。

以前在学校的时候，我有两台电脑，一台赛扬和一台 486。我经常在上面重装系统，一会儿装 Linux，一会儿装 NT，一会儿又装 Netware。虽 然我经常把代码备份到不同的分区上， 结果还不小心把所有分区全干掉了，让我痛心不已。那只是写的一些小程序，重写一遍问题也不大，但是对于专业程序员或一个软件团队来说，重写整个代码就不能接受了，所以需要更可靠的备份机制。

使用源代码管理系统还不能保证代码的安全，比如服务器硬盘损坏和办公室发生火灾等都是可能发生。团队里一定要有人负责定期备份源代码管理系统系统上 的资料，作为初学者也应该有这种意识。另外，我发现有些朋友把重要的资料放在邮箱里，现在的邮箱容量很大， 因为提供商会定期备份，非常安全，这倒是一个不错的主意。

**状态不好就做点别的**

女同胞有定期状态不佳的时候，男同胞也不是每天状态都很好。感冒了、丢东西了、或者家人争吵了，都会影响你的状态。状态不好的时候做事，往往是进一 步退两步，甚至犯下严重的错误。有次我得了重感冒，居然在服务器的根目录下运行 rm * -rf(删除全部文件)，由于删除的时间太长，才让我发现删错地方了，吓得我出了一身冷汗，还好那台服务器不是运行着源代码管理系统，但还是浪费了我两天时间去重建服务器上的环境。

状态不好的时候编程也会犯一些低级错误，让你花费更多时间去调试。总要言之，状态不好的去做重要的事有害无益，这时你不防去做点别做的，比如看看其它模块的代码之类的，甚至完全放松去休息都比犯下严重的错误强。

